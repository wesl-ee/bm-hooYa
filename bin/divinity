#!/usr/bin/perl
use strict;
use Getopt::Long 'HelpMessage';
use DBI;
use File::Find;
use File::MimeInfo 'mimetype';
use Digest::MD5 'md5_hex';

# Cute formatting; ANSI escape codes
use constant HOOYA_VERSION => '0.5';
use constant {
	FG_BLACK => '[0;30m',
	FG_RED => '[0;31m',
	FG_GREEN => '[0;32m',
	FG_YELLOW => '[0;33m',
	FG_BLUE => '[0;34m',
	FG_MAGENTA => '[0;35m',
	FG_CYAN => '[0;36m',
	FG_WHITE => '[0;37m',
	FG_DEFAULT => '[0;39m',

	BG_BLACK => '[0;40m',
	BG_RED => '[0;41m',
	BG_GREEN => '[0;42m',
	BG_YELLOW => '[0;43m',
	BG_BLUE => '[0;44m',
	BG_MAGENTA => '[0;45m',
	BG_CYAN => '[0;46m',
	BG_WHITE => '[0;47m',
	BG_DEFAULT => '[0;49m',

	TEXT_RESET => '[0;0m',
	TEXT_BOLD => '[0;1m',
	TEXT_STANDOUT => '[0;3m',
	TEXT_BLINK => '[0;5m',
	TEXT_REVERSE => '[0;7m',
};

# Disable buffering
$| = 1;

sub die_error { die FG_RED . @_[0] . FG_DEFAULT . "\n"; }
sub notify_success { print FG_GREEN . @_[0] . FG_DEFAULT . "\n"; }
sub notify_warn { print FG_YELLOW . @_[0] . FG_DEFAULT . "\n"; }
sub status_update {
	my ($current, $total) = @_;
	my $percent = ($current/$total)*100;

	printf("\33[2K\r");
	printf("%.f%% done (%d / %d)", $percent, $current, $total);
	print "\n" if ($current == $total);
}

GetOptions(
	'help' => sub { HelpMessage(0) },

	# Import directory options
	'import' => \my $import,
	'directory=s' => \my $directory,
	'class=s' => \my $class,

	# Unmap key options
	'unmap' => \my $unmap,
	'delete' => \my $delete,
	'key=s' => \my $key,

	#For both
	'namespace=s' => \my @namespaces,
	'tag=s' => \my @tags,
) or HelpMessage(1);

HelpMessage(1) unless (defined $unmap || $import || $delete);

# Read SQL settings from the config file
my ($CONFIG_MYSQL_HOOYA_HOST,
$CONFIG_MYSQL_HOOYA_USER,
$CONFIG_MYSQL_HOOYA_PASSWORD,
$CONFIG_MYSQL_HOOYA_DATABASE);

# Definitely going to need to make a config file in /etc
my $incfile =  '/var/http/hub/hooYa/includes/config.php';
open(FILE, $incfile);
while (<FILE>) {
	$CONFIG_MYSQL_HOOYA_HOST = $1 if (/["']CONFIG_MYSQL_HOOYA_HOST["'], ["'](.+)["']/);
	$CONFIG_MYSQL_HOOYA_USER = $1 if (/"CONFIG_MYSQL_HOOYA_USER", ["'](.+)["']/);
	$CONFIG_MYSQL_HOOYA_PASSWORD = $1 if (/["']CONFIG_MYSQL_HOOYA_PASSWORD["'], ["'](.+)["']/);
	$CONFIG_MYSQL_HOOYA_DATABASE = $1 if (/["']CONFIG_MYSQL_HOOYA_DATABASE["'], ["'](.+)["']/);
}
close(FILE);

# Introduction, version identification
print FG_GREEN
	. "hooYa v" . HOOYA_VERSION
	. " mangement interface\n"
. FG_DEFAULT;

# SQL
my $dsn = "DBI:mysql:database=" . $CONFIG_MYSQL_HOOYA_DATABASE
. ";host=" . $CONFIG_MYSQL_HOOYA_HOST;

my $dbh = DBI->connect(
	$dsn,
	$CONFIG_MYSQL_HOOYA_USER,
	$CONFIG_MYSQL_HOOYA_PASSWORD,
	{'PrintError' => 0}
);
if (!defined $dbh) {
	die_error DBI::errstr;
}
my $sth;

# Importing
if (defined $import) {
	if (!defined $directory) {
		print "Directory or file to map: ";
		my $directory = <STDIN>;
		chomp $directory;
	}
	if (!(-d $directory || -f $directory)) {
		die_error "$directory is not a directory or a file";
	}

	if (@namespaces && @tags) {
		die_error "Number of namespaces does not match"
		. " the number of tags" if (@namespaces != @tags);
		for (my $i = 0; $i < @namespaces; $i++) {
			$sth = $dbh->prepare('INSERT INTO `Tags`'
			. ' (`Space`, `Member`) VALUES'
			. " (?, ?)"
			. " ON DUPLICATE KEY UPDATE `Member`=?");
			$sth->execute($namespaces[$i], $tags[$i], $tags[$i]) or die_error DBI::errstr;
		}
	}
	if (-f $directory) {
		notify_success("Importing 1 file of "
		. scaledbytes(-s $directory) . " size");
		importfile($directory);
	}
	else {
		my ($total, $size, @files, $n);
		find(sub {$total++ if -f; $size+= -s if -f;
			push @files, $File::Find::name if -f}, $directory);
		notify_success("Importing $total files ("
		. &scaledbytes($size) . "). . . ");
		$n = 0;
		foreach (@files) {
			status_update ($n++, $total);
			importfile($_);

		}
	}
	notify_success("Done!");
}

# Unmapping
elsif (defined $unmap || $delete) {
	if (!defined $key) {
		print "Key to unmap: ";
		$key = <STDIN>;
		chomp $key;
	}
	if (defined $delete) {
		$sth = $dbh->prepare("SELECT Path FROM `Files` WHERE Id='$key'");
		$sth->execute or die_error DBI::errstr;
		my $row = $sth->fetchrow_hashref;
		if (!defined $row) {
			die_error "No such key $key is mapped";
		}
		my $path = $row->{'Path'};
		if (!unlink $path) {
			die_error "Could not unlink file $path";
		}
		notify_success "Deleted file $path";
	}
	$sth = $dbh->prepare("DELETE FROM `Files` WHERE Id='$key'");
	$sth->execute or die_error DBI::errstr;
	if (!$sth->rows) {
		die_error "No such key $key is mapped";
	}
	notify_success "Successfully unmapped $key";
}

# Function definitions
sub importfile {
	return if !-f;
	my $md5 = md5_hex(do { local $/; IO::File->new($_)->getline }, 0);
	my $path = $_;
	my $mtype = mimetype($_);
	my $ftype = (split(/\//, $mtype))[0];
	my $size = -s $_;

	if (!defined $class) {
		# Default classes
		if ($ftype eq 'image') {$class = 'single_image'}
		if ($ftype eq 'video') {$class = 'video'}
	}
	$sth = $dbh->prepare("INSERT INTO `Files`"
	. " (`Id`, `Path`, `Size`, `Class`, `Mimetype`) VALUES"
	. " (?, ?, ?, ?, ?)"
	. "ON DUPLICATE KEY UPDATE"
	. " `Id`=?, `Path`=?, `Size`=?,"
	. " `Class`=?, `Mimetype`=?");
	$sth->execute($md5, $path, $size, $class, $mtype,
		$md5, $path, $size, $class, $mtype)
		or die_error DBI::errstr;

	if (@namespaces && @tags) {
		for (my $i = 0; $i < @namespaces; $i++) {
			$sth = $dbh->prepare('INSERT INTO `TagMap`'
			. " (`FileId`, `TagId`) SELECT ? AS FileId, Id AS TagId"
			. " FROM `Tags` WHERE `Space`=?"
			. " AND `Member`=? ON DUPLICATE KEY UPDATE `FileId`=?");
			$sth->execute($md5, $tags[$i], $namespaces[$i], $md5) or die_error DBI::errstr;
		}
	}
}
sub scaledbytes {
	(sort { length $a <=> length $b }
	map { sprintf '%.3g%s', $_[0]/1024**$_->[1], $_->[0] }
	[" bytes"=>0],[KB=>1],[MB=>2],[GB=>3],[TB=>4],[PB=>5],[EB=>6])[0]
}

=pod

=head1 NAME

divinity - hooYa management interface

=head1 SYNOPSIS

Exactly one of the following must be specified:

=over

=item --import

=item --delete

=item --unmap

=back

Delete / unmap options

=over

=item --key

=back

Import options

=over

=item --directory

=item --class

=item --namespace

=item --tag

=back

=head1 VERSION

0.5
