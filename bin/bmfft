#!/usr/bin/perl -w
use strict;
use XML::LibXML;
use Curses;
use XML::LibXML::PrettyPrint;
use Digest::MD5::File 'file_md5_base64';
use Cwd 'abs_path';

use bmfft_db qw (&bmfft_update_db);

# Pass the directory you want to checkout as an argument
# Protip: must have a .tags.xml in the root of the directory
# otherwise you must generate one using gen_xml
my $tagfile = shift;
if (!$tagfile) {
	print "Usage: ./bmfft (tagfile)\n";
	exit -1;
}
$tagfile = abs_path($tagfile);

# Initialize the screen
my $curses = new Curses;

initscr;
start_color();
noecho;
cbreak;
keypad(1);
curs_set(0);

# Initialize colors
init_pair(1, COLOR_WHITE, COLOR_BLUE);
init_pair(2, COLOR_BLACK, COLOR_WHITE);

# Create aa new boxed window for displaying the current
# directory contents
my $twin= newwin(1, getmaxx()-2, 1, 1);
my $bwin = newwin(getmaxy()-4, getmaxx()-2, 2, 1);

# Browse a bunch of items, navigating by the 'j' and 'k'
# keys. Returns a two-element array which contains
# 	1.) The selected element's index
# 	2.) The key pressed on the selected element
# ofc 'h' and 'j' do not fire becuase they navigate the
# menu ;)
sub browse {
	my $c;
	my $selecteditem = 0;
	my $page = 0;
	my $head = shift;
	my @listing = @_;
	clear $bwin;
	bkgd($bwin, COLOR_PAIR(0));
	# Loop for browsing contents
	do {
		# Make sure that the titlebar is there
		my $message = $head." (page ".($page+1).")";
		attron($twin, A_REVERSE);
		addstr($twin, 0, (getmaxx($twin)-length($message))/2, $message);
		attroff($twin, A_REVERSE);
		refresh $twin;

		# Lower boundary check
		if ($selecteditem < 0) {
			$selecteditem = 0;
		}
		# Upper boundary check
		elsif ($selecteditem > @listing-1) {
			$selecteditem = @listing-1;
		}

		# Display the current directory's contents, putting a * beside
		# the selected file
		for my $i ($page*getmaxy($bwin)..$page*getmaxy($bwin)+getmaxy($bwin)-1) {
			if ($i >= @listing) {
				last;
			}
			if ($selecteditem == $i) {
				addstr($bwin, $i%getmaxy($bwin), 0, "*");
			}
			addstr($bwin, $i%getmaxy($bwin), 2, $listing[$i]);
		}
		# Update changes, wait for user input
		refresh $bwin;
		$c = getch $bwin;

		# The user wants to backtrack one file
		if ($c eq 'k') {
			addstr($bwin, $selecteditem%getmaxy($bwin), 0, ' ');
			$selecteditem--;
			# Should we go back one page?
			if ($selecteditem < $page*getmaxy($bwin) && $page > 0) {
				clear $bwin;
				$page -= 1;
			}
		}
		# The user wants to advance one file
		elsif ($c eq 'j') {
			addstr($bwin, $selecteditem%getmaxy($bwin), 0, ' ');
			$selecteditem++;
			# Should we advance the page?
			if ($selecteditem > $page*getmaxy($bwin)+getmaxy($bwin)-1 && @listing > $page*getmaxy($bwin)+getmaxy($bwin)-1) {
				clear $bwin;
				$page += 1;
			}
		}
		# The user wants to advance one page
		elsif ($c eq 'J') {
			# Only if we're not on the last page!
			if (@listing > $page*getmaxy($bwin)+getmaxy($bwin)-1) {
				$selecteditem += getmaxy($bwin);
				clear $bwin;
				$page += 1;
			}
		}
		# The user wants to backtrack one page
		elsif ($c eq 'K') {
			if ($page > 0) {
			# Only if we're not on the first page!
				$selecteditem -= getmaxy($bwin);
				clear $bwin;
				$page -= 1;
			}
		}
		else {
			clear $bwin; refresh $bwin;
			clear $twin; refresh $twin;
			return ($selecteditem, $c);
		}
	} while ($c);
}
sub choices
{
	my $message = shift or die;
	my @items = @_;
	my $win = newwin(getmaxy()-10, getmaxx()-10, 5, 5);
	box($win, 0, 0);
	bkgd($win, COLOR_PAIR(1));

	addstr($win, 0, (getmaxx($win)-length($message))/2, $message);

	for (my $i = 1; @items; $i++) {
		my $message = shift @items;
		addstr($win, $i+1, 2, "$i.) ".$message);
	}
	refresh $win;
	my $key = getch $win;
	clear $win;
	bkgd($win, COLOR_PAIR(0)); refresh $win;
	delwin $win;
	$key;
}
# Bring up the tag editing sub-window
sub edit_tags
{
	# Create the dialog
	my $tagwin = newwin(getmaxy()-20, getmaxx()-20, 10, 10);
	# Make a cute border and bg color
	box($tagwin, 0, 0);
	bkgd($tagwin, COLOR_PAIR(1));

	# Create a tile/header
#	my $header = "Tags for " . @listing[$_[0]];
#	addstr($tagwin, 0, (getmaxx($tagwin)-length($header))/2, $header);
	addstr($tagwin, 2, 1, "Features coming soon!");
	refresh($tagwin);
	getch $tagwin;
	clear $tagwin;
	delwin($tagwin);
}
# Display a cute alert!
sub alert
{
	# Create the dialog
	my $tagwin = newwin(getmaxy()-20, getmaxx()-20, 10, 10);
	my $message = $_[0];
	my $title = " ".$_[1]." ";
	box($tagwin, 0, 0);
	bkgd($tagwin, COLOR_PAIR(1));

	# Create a tile/header
	if ($title) {
		addstr($tagwin, 0, (getmaxx($tagwin)-length($title))/2, $title);
	}
	addstr($tagwin, (getmaxy($tagwin)/2), (getmaxx($tagwin)-length($message))/2, $message);
	refresh($tagwin);
	getch $tagwin;
	bkgd($tagwin, COLOR_PAIR(0));
	clear $tagwin;
	delwin($tagwin);
}
sub help_menu
{
	# Create the dialog
	my $helpwin = newwin(getmaxy()-20, getmaxx()-20, 10, 10);
	# Make a cute border and bg color
	box($helpwin, 0, 0);
	bkgd($helpwin, COLOR_PAIR(1));

	# Create a tile/header
	my $header = " bmfft help ";
	addstr($helpwin, 0, (getmaxx($helpwin)-length($header))/2, $header);
	# Help entries. . . soon to be read from a help file in doc/
	addstr($helpwin, 2, (getmaxx($helpwin)-length("h - left"))/2, "h - left");
	addstr($helpwin, 3, (getmaxx($helpwin)-length("j - down"))/2, "j - down");
	addstr($helpwin, 4, (getmaxx($helpwin)-length("k - up"))/2, "k - up");
	addstr($helpwin, 5, (getmaxx($helpwin)-length("l - right"))/2, "l - right");
	addstr($helpwin, 6, (getmaxx($helpwin)-length("e - edit tag"))/2, "e - edit tag");
	addstr($helpwin, 7, (getmaxx($helpwin)-length("q - quit"))/2, "q - quit");
	addstr($helpwin, 8, (getmaxx($helpwin)-length("? - help menu"))/2, "? - help menu");
	refresh($helpwin);
	getch $helpwin;
	# Temporary until I figure out how to cleanly restore the window
	# underneath
	clear $helpwin;
	delwin($helpwin);
}
sub dialog
{
	my $message = shift or die;
	addstr($bwin, getmaxy()/3-1, (getmaxx()-length($message))/2, $message);
	my $QUERYLEN = 50;
	my $query;
	$message = " bmfft search ";
	addstr($bwin, 0, (getmaxx()-length($message))/2, $message);

	attrset($bwin, A_REVERSE);
	foreach (getmaxx()/2-($QUERYLEN/2)..getmaxx()/2+($QUERYLEN/2)) {
		addch($bwin, getmaxy()/3, $_, ' ');
	}
	my $c;
	move($bwin, getmaxy()/3, getmaxx()/2-($QUERYLEN/2));
	# Eventually bounds-check as the user enters characters
	echo;
	refresh;
	$query = getstring $bwin;
	attroff($bwin, A_REVERSE);
	noecho;
	clear $bwin; refresh $bwin;
	$query;
#	do {
#		$c = getch();
#		if ($c eq '\c?') {
#			addch($c);
#		}
#	} while ($c ne '\R');
}
sub human_filesize
{
        my $size = shift;
        #TiB
        if ($size > 1099511627776) { return sprintf("%.2f TiB", $size / 1099511627776); }
        # GiB
        elsif ($size > 1073741824) { return sprintf("%.2f GiB", $size / 1073741824); }
        # MiB
        elsif ($size > 1048576) { return sprintf("%.2f MiB", $size / 1048576); }
        # KiB
        elsif ($size > 1024) { return sprintf("%.2f KiB", $size / 1024); }
        # Bytes
        else {return "$size byte" . ($size == 1 ? "" : "s"); }
}
# Greet the user!
my $win = newwin(getmaxy()-10, getmaxx()-10, 5, 5);
my $message;
# Make a cute border and bg color
box($win, 0, 0);
bkgd($win, COLOR_PAIR(1));
refresh $win; 

# Create a tile/header
$message = " welcome to bmfft ";
addstr($win, 0, (getmaxx($win)-length($message))/2, $message);
$message = 'bmfft stands for big mike\'s fancy file tagger!';
addstr($win, 1, (getmaxx($win)-length($message))/2, $message);
$message = 'send complaints to nakomi@bigmike.sne.jp';
addstr($win, getmaxy($win)-2, (getmaxx($win)-length($message))/2, $message);

$message = 'any key continues. . .';
addstr($win, getmaxy($win)-3, (getmaxx($win)-length($message))/2, $message);
refresh $win;

# Wait for user to click past the greeting
getch $win;
clear $win;
bkgd($win, COLOR_PAIR(0));
delwin($win);

while (1) {
	my $c = choices(' welcome to bmfft! ', 'import files to DB', 'remove file from DB', 'update DB', 'archive all files to .tar.bz2', 'search', 'recursively tag by directory');

	if ($c eq '1') {
		my $message;
		my $path = dialog('enter an absolute path to index');
		if (!(-e $path)) {
			$message = 'couldn\'t find that path!';
			alert('ERROR!', 'Couldn\'t find path');
			clear $bwin;
			next;
		}
		$path = abs_path($path);
		my $win = newwin(getmaxy()-10, getmaxx()-10, 5, 5);
		box($win, 0, 0);
		bkgd($win, COLOR_PAIR(1));

		# Create a tile/header
		$message = " updating your db ";
		addstr($win, 0, (getmaxx($win)-length($message))/2, $message);

		# Calculate database size and the number of files
		my $i;
		my $size;
		refresh $win;
		find ( sub {$i++ if -f; $size += -s if -f}, $path);
		$message = "Generating MD5 hashes for $i files (".human_filesize($size).")";
		addstr($win, getmaxy($win)/2, (getmaxx($win)-length($message))/2, $message);
		$message = "Please wait. . .";
		addstr($win, getmaxy($win)/2+1, (getmaxx($win)-length($message))/2, $message);
		refresh $win;
		&bmfft_update_db($path, $tagfile);
		clear $bwin;
		bkgd($win, COLOR_PAIR(0));
		delwin($win);
	}
	if ($c eq '2') {
		my $key = &dialog('md5 sum of the file you want to delete');
		if (!&bmfft_exists($tagfile, $key)) {
			&alert('that file is not indexed!', ' 404 file not found ');
			next;
		}
		my $path = &bmfft_getattr($tagfile, $key, 'path');
		&bmfft_remove($tagfile, $key);
		if (&choices(' Delete this file from the filesystem too? ', 'Yes', 'No') eq '1') {
			if (!unlink($path)) {
				&alert('Could not delete '.$path, ' Permissions error ');
			}
			else {
				&alert($path.' deleted!', ' Success! ');
			}
		}
		else {
		}
	}
	if ($c eq '3') {
		alert('not yet implemented', 'future');
	}
	if ($c eq '4') {
		my $tarfile = &dialog('please specify the .tar.bz2 file you wish to create');
		alert('not yet implemented', 'future');
	}
	if ($c eq '5') {
		# Prompt the user to search some tags
		my @tags = split(/,/, &dialog('hooYa!'));
		my @items;
		foreach my $tag (@tags) {
			foreach my $key (bmfft_searchtag($tagfile, $tag)) {
				push @items, bmfft_getattr($tagfile, $key, 'name');
			}
		}
		browse("Files that match " . join(",", @tags), @items);
		clear $bwin;
		bkgd($bwin, COLOR_PAIR(0));
	}
	if ($c eq '6') {
		alert('not yet implemented', 'future');
	}
	if ($c eq 'q') {
		endwin;
		exit;
	}
}
